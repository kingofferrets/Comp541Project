// KeccakTools Equation Converter
// Author: Jonathan Sharman
// 
// Converts the ANF-like equations generated by KeccakTools into CNF-with-XOR.

#include <iostream>
#include <fstream>
#include <map>
#include <string>
#include <vector>

using namespace std;

//const int permutation_width = 50;
//const int var_name_len = 3;
//const string problem_name = "Eq-KeccakF-50-4-rounds";

//const int permutation_width = 50;
//const int var_name_len = 3;
//const string problem_name = "Eq-KeccakF-50-5-rounds";

const int permutation_width = 1600;
const int var_name_len = 4;
const string problem_name = "Eq-KeccakF-1600-3-rounds";

map<string, int> ivars;
map<string, int> ovars;
int make_var()
{
	static int next = 1;
	return next++;
}
int get_ivar(string var_name)
{
	auto it = ivars.find(var_name);
	if (it != ivars.end()) {
		return it->second;
	} else {
		int var = make_var();
		ivars[var_name] = var;
		return var;
	}
}

class Clause
{
public:
	Clause(vector<int> terms, bool xor) : terms{move(terms)}, xor{xor} {}

	friend ostream& operator <<(ostream& out, const Clause& c)
	{
		if (c.xor) {
			out << 'x';
		}
		for (int term : c.terms) {
			out << term << ' ';
		}
		out << '0';
		return out;
	}
private:
	vector<int> terms;
	bool xor;
};

vector<Clause> clauses;

void trim(string& input)
{
	int i = 0;
	while (input[i] == ' ') ++i;
	input.erase(0, i);
}

vector<int> parse_clause(string&);

int parse_factor(string& input)
{
	// Parse Iba | (Iba + 1) | etc.

	trim(input);
	// Check for parenthetical term.
	if (input.front() == '(') {
		// Find closing parenthesis.
		int parity = 1;
		int i = 2;
		while (parity > 0) {
			if (input[i] == '(') {
				++parity;
			} else if (input[i] == ')') {
				--parity;
			}
			++i;
		}
		// i is the length of the parenthesized clause (including parens) and points to the first character past the closing paren.
		string subclause = input.substr(1, i - 2); // Exclude parens.

		// Create a new variable, assinging it to the subclause and substituting it in for the subclause.

		vector<int> parsed_subclause = parse_clause(subclause);
		int lhs = make_var();
		vector<int> assignment;
		// Add not(lhs) to assignment clause.
		assignment.push_back(-lhs);
		// Add parsed subterm to assignment clause.
		assignment.insert(assignment.end(), parsed_subclause.begin(), parsed_subclause.end());
		// Add full assignment clause to clauses list.
		clauses.push_back(Clause{assignment, true});

		input = input.substr(i);
		return lhs;
	}
	// Check for literal.
	if ('A' <= input.front() && input.front() <= 'z') {
		int term = get_ivar(input.substr(1, var_name_len));
		input = input.substr(3);
		// Check for negation.
		if (input.length() >= 4 && input.substr(0, 4) == " + 1") {
			input = input.substr(4);
			return -term;
		} else {
			return term;
		}
	}
	throw exception{"Failed to parse term."};
}

int and(vector<int> factors)
{
	if (factors.size() == 1) return factors.front();

	// a = b and c === (-a or b) and (-a or c) and (a or -b or -c)
	int a = make_var();
	int b = factors[0];
	int c = factors[1];
	clauses.push_back(Clause{vector<int>{-a, b}, false});
	clauses.push_back(Clause{vector<int>{-a, c}, false});
	clauses.push_back(Clause{vector<int>{a, -b, -c}, false});

	vector<int> new_factors;
	new_factors.push_back(a);
	new_factors.insert(new_factors.end(), factors.begin() + 2, factors.end());
	return and(new_factors);
}

int parse_term(string& input)
{
	// Parse f1*f2*...

	vector<int> factors;
	factors.push_back(parse_factor(input));
	trim(input);
	while (input.size() > 0 && input.front() == '*') {
		input = input.substr(1);
		factors.push_back(parse_factor(input));
	}
	return and(factors);
}

vector<int> parse_clause(string& input)
{
	// Parse t1 + t2 + ...

	vector<int> clause;
	clause.push_back(parse_term(input));
	while (input.size() > 0 && input.front() == '+') {
		input = input.substr(1);
		clause.push_back(parse_term(input));
	}
	return clause;
}

void parse_assignment(string line)
{
	// First var_name_len after the first are the new output variable.
	string lhs = line.substr(1, var_name_len);

	// Characters after the = sign are the RHS clause.
	string rhs = line.substr(4 + var_name_len);

	// Reassign LHS symbol.
	ovars[lhs] = make_var();

	vector<int> assignment;
	// Add not(LHS) to assignment clause.
	assignment.push_back(-ovars[lhs]);
	// Parse RHS, simplifying to XOR's only.
	vector<int> rhs_clause = parse_clause(rhs);
	// Add parsed RHS to assignment clause.
	assignment.insert(assignment.end(), rhs_clause.begin(), rhs_clause.end());

	// Add full assignment clause to clauses list.
	clauses.push_back(Clause{assignment, true});
}

int main()
{
	ifstream fin{problem_name + ".txt"};
	string line;
	int i = 0;
	while (getline(fin, line)) {
		if (line.front() == '/' || line.empty()) continue;
		// If the line is not empty or a comment, it's an assignment.
		parse_assignment(line);

		// Process permutation_width lines, and then swap input and output variables.
		++i;
		if (i == permutation_width) {
			ivars = ovars;
			ovars.clear();
			i = 0;
		}
	}

	// Set last set of ivars to true.
	for (auto pair : ivars) {
		clauses.push_back(Clause{vector<int>{pair.second}, false});
	}

	ofstream fout{problem_name + ".xor"};
	fout << "p cnf " << make_var() << " " << clauses.size() << endl;
	for (const Clause& clause : clauses) {
		fout << clause << endl;
	}

	return 0;
}
