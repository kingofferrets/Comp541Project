\section{Creating SAT Formula Benchmarks}
\label{sec:encoding}

In this section, we generate SAT formulas that encode attacks on various cryptographic ciphers and hash functions. In particular we encode two ciphers-- the Crypto-1 Stream-Cipher and DES-- and one hash function-- MD4-- as SAT formulas. A \emph{SAT Formula} is the disjunction of or-clauses and xor-clauses; we define this more carefully in Section \ref{sec:encoding:desc}. In Section \ref{sec:encoding:desc} we describe exactly what we mean by a SAT formula that encodes an attack on a cryptographic tool. In Sections \ref{sec:encoding:crypto1}, \ref{sec:encoding:md4}, and \ref{sec:encoding:des} we discuss the details of encoding each attack.

\subsection{SAT: Boolean Satisfiability}
\label{sec:encoding:sat}

A \emph{Boolean formula} is an expression constructed from combining boolean variables using the unary operator $\neg$, representing negation, and the binary operators $\land$, $\lor$, $\oplus$ representing respectively and (i.e. conjunction), or (i.e. disjunction), and exclusive or (i.e. xor). We say a boolean formula is \emph{satisfied} by an assignment of true or false to each variables if the expression evaluates to true under the assignment.

For example, $(p \lor q) \oplus \neg r$ is a boolean formula over the set of boolean variables $\{p, q, r\}$. If we compute all satisfying assignments of this formula, we see that the assignment to $r$ must be equal to the value of $p \text{ or } q$. Thus we say that this formula \emph{encodes} the equation $r = p \text{ or } q$. This idea of encoding an equation will be discussed more carefully in Section \ref{sec:encoding:desc}

The problem of Boolean Satisfiability (or SAT) is, given a boolean formula, to find and return a satisfying assignment of the boolean formula or report that the formula has no satisfying assignments. A \emph{SAT solver}, then, is a tool to finding a satisfying assignment of a provided boolean formula. In Section \ref{sec:related:solvers}, we discuss several popular SAT solvers. These SAT solvers typically demand that the input boolean formulas have a precise structure. 

A \emph{literal} is a boolean variable or the negation of a boolean variable. A clause consists of a set of literals joined together by some boolean operation. An \emph{or-clause} (elsewhere called a CNF-clause) joins literals together with $\lor$. An \emph{xor-clause} joins literals together using $\oplus$. For example, $(a \lor b \lor \neg c)$ is an or-clause and $(\neg a \oplus b)$ is an xor-clause. Both MiniSat and Glucose demand that the boolean formula be input as the conjunction of some number of or-clauses. This structure is standardized across most SAT solvers; one can show that all boolean formulas can be rewritten in this form with only a small (meaning bounded by some polynomial) increase in size. However, not all solvers demand the same input format. The CryptoMiniSat \cite{SNC09} solver allows the input formula to be the conjunction of both or-clauses and xor-clauses . 

We thus define a \emph{SAT formula} to be boolean formula consisting of the conjunction of or-clauses and xor-clauses. This formula can be directly input into the CryptoMiniSat solver. To input these benchmarks into Glucose and MiniSat, we use a python tool\footnote{https://github.com/msoos/cnf-utils} included in CryptoMiniSat to first convert the SAT formulas into boolean formulas consisting only of the conjunction of or-clauses. In this way, we can run a single SAT formula benchmark against a wide variety of SAT solvers.


\subsection{Encoding Cryptographic Attacks as SAT Formulas}
\label{sec:encoding:desc}
We can imagine each of these cryptographic tools as a function from a set of input bits to a set of output 
bits. Such a function is called a \emph{boolean function}. For example, MD4 is one particular function from a set of 512 input bits to a set of 128 output bits. Cryptographic ciphers like DES include the key in the set of input bits. To encode a cryptographic cipher or hash function as a SAT formula, we can find an encoding of the corresponding boolean function as a SAT formula.

One way to encode a boolean function as a SAT formula is essentially by enumeration. We represent each input bit and each output bit by distinct boolean variables. In the case of MD4, we can encode $2^{512}$ statements of the form "if the input bits are $\hex{000...00}$, the MD4 output is $\hex{31d...c0}$". However, such an encoding is prohibitively large for most non-trivial boolean functions.

The specification for these cryptographic tools is not a table with exponentially many entries; instead, the specification describes a series of steps to compute the output bits when given the input bits. To obtain a compact encoding of a boolean function, we can encode the entire specification instead of directly encoding input/output pairs. We again represent each input bit and each output bit by distinct boolean variables. In addition, we also introduce distinct boolean variables for each bit computed by the specification in a single step. These intermediate variables allow us to encode each step of the specification with a small (i.e. polynomial) number of SAT formulas. For example, if $i$ and $j$ are input bits with corresponding boolean variables $x_i$ and $x_j$ and the specification calls to compute $a = (i \text{ or } j)$, we introduce a new boolean variable $x_a$ and include the clause $x_a = x_i \lor x_j$ in our SAT formula.\footnote{Because we are restricted to only or-clauses and xor-clauses, we must encode this clause further as the three or-clauses $\neg x_a \lor x_i \lor x_j$, $x_a \lor \neg x_i$, and $x_a \lor \neg x_j$}

Encoding the specification in this way gives us a SAT formula over three sets of variables: a set corresponding to the input, a set corresponding to the output, and a set corresponding to intermediate computations. A satisfying assignment of this formula is exactly a trace of the specification: the assignments of the input variables correspond to the bits input of the function, the assignments of the output variables correspond to the bits output by the function, and the assignments of the intermediate variables correspond the to the bits computed by the specification along the way. Thus for every assignment to the input variables there is exactly one assignment to the output and intermediate variables which satisfies the formula. This fact is useful to test that the encoding is correct; simply set the input variables, solve the formula (which, since all intermediate variables are forced by the input variables, should be an easy computation), and test that the output variables correspond to the correct output of the function.

It is more interesting to use this encoding to invert a boolean function. By setting the output variables and finding an assignment to the input and intermediate variables that satisfies the SAT formula, we can find an input to the boolean function that corresponds to the given output. If this boolean function is actually a cryptographic hash function, solving for the input variables after providing the output variables corresponds to inverting the hash function.  If this boolean function is actually a cryptographic cipher, solving for the key variables after providing the input and output variables corresponds to deducing the key of the cipher from sample plain text and encrypted text. In both cases, this breaks the cryptographic guarantees. Thus an encoding of a cryptographic problem as a SAT formula gives you a line of attack on the cryptography. In the following sections, we describe four cryptographic attacks encoded as SAT formulas.