\section{Creating SAT Formula Benchmarks}
\label{sec:encoding}

In this section, we generate SAT formulas that encode various cryptographic ciphers and hash functions. In particular we encode two ciphers-- the Crypto-1 Stream-Cipher and DES-- and two hash functions-- MD4 and SHA-3-- as SAT formulas. In Section \ref{sec:encoding:desc} we describe exactly what we mean by a SAT formula that encodes a cryptographic cipher and hash function. In Sections \ref{sec:encoding:crypto1}, \ref{sec:encoding:md4}, \ref{sec:encoding:des}, and \ref{sec:encoding:keccak} we discuss the details of encoding each cryptographic tool.

\subsection{Encoding Cryptography in SAT}
\label{sec:encoding:desc}
We can imagine each of these cryptographic tools as a function from a set of input bits to a set of output 
bits. Such a function is called a \emph{boolean function}. For example, MD4 is one particular function from a set of 512 input bits to a set of 128 output bits. Cryptographic ciphers like DES include the key in the set of input bits. To encode a cryptographic cipher or hash function as a SAT formula, we can find an encoding of the corresponding boolean function as a SAT formula.

One way to encode a boolean function as a SAT formula is essentially by enumeration. We represent each input bit and each output bit by distinct boolean variables. In the case of MD4, we can encode $2^{512}$ statements of the form "if the input bits are $\hex{000 \cdots 00}$, the MD4 output is $\hex{31d \cdots c0}$". However, it should be clear that such an encoding is prohibitively large for most non-trivial boolean functions.

The specification for these cryptographic tools is not a table with exponentially many entries; instead, the specification describes a series of steps to compute the output bits when given the input bits. To obtain a compact encoding of a boolean function, we can encode the entire specification instead of directly encoding input/output pairs. We again represent each input bit and each output bit by distinct boolean variables. In addition, we also introduce distinct boolean variables for each bit computed by the specification in a single step. These intermediate variables allow us to encode each step of the specification with a small (i.e. polynomial) number of SAT formulas. For example, if $i$ and $j$ are input bits with corresponding boolean variables $x_i$ and $x_j$ and the specification calls to compute $a = i \lor j$, we introduce a new boolean variable $x_a$ and include the clause $x_a = x_i \lor x_j$ in our SAT formula . \footnote{Because we are restricted to only CNF and XOR clauses, we must encode this clause further as the three CNF clauses $\neg x_a \lor x_i \lor x_j$, $x_a \lor \neg x_i$, and $x_a \lor \neg x_j$}

Encoding the specification in this way gives us a SAT formula over three sets of variables: a set corresponding to the input, a set corresponding to the output, and a set corresponding to intermediate computations. A satisfying assignment of this formula is exactly a trace of the specification: the assignments of the input variables correspond to the bits input of the function, the assignments of the output variables correspond to the bits output by the function, and the assignments of the intermediate variables correspond the to the bits computed by the specification along the way. Thus for every assignment to the input variables there is exactly one assignment to the output and intermediate variables which satisfies the formula. This fact is useful to test that the encoding is correct; simply set the input variables, solve the formula (which, since all intermediate variables are forced by the input, should be an easy computation), and test that the output variables correspond to the correct output.

It is more interesting to use this encoding to \emph{invert} a boolean function. By setting the output variables and finding an assignment to the input and intermediate variables that satisfies the SAT formula, we can find an input to the boolean function that corresponds to the given output.